### Обработчик сигнала sig_handler регистрируется для процесса, а не потока
Есть битовые маски обработки сигналов для каждого потока и для процесса
Порядок масок принятия сигнала:
 - pending
 - blocked - заблокирован, но оставлен в ожидании
 - ignore - сбрасывает сигнал
если блок и игонр поменять местами то чет не так будет  
cat /proc/[pid]/status | grep Sig
не блокируется kill и (stop?) 
kill -9 [pid]

syskill
tgkill - для потока

можно оставить исполнение обработчиков сигналов на отдельные потоки


sleep - task_interapteable/task_inuntera - можно ли разбудить сигналом

Механизм состоит из двух шагов
Генерация сигнала - регитсрация сигнала в структуре процесса
Доставка сигнала - сложная вещь



сигнал доставляется процессу либо потоку

после обработчика сигнала управление возвращается в ядро, чтобы корректно продолжить работу, вызов сигхандлера не должен быть заметным.
сохраняем контекст на стек
do_signal
sig_return
нужен универсальный метод асинхронного вызова обработчика сигналов

универсаьный способ в 99% не писать хэндлер
в 1% делал отладку процесса
хэндлер лучше быстрее завершать - регистрировать событие, выставлять флаг, а потом в контексте реаигровать