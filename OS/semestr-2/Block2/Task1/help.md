## Синхронизация

А когда она нужна? т.к. это накладные расходы\
pthread_setaffinity_np - привязывает поток к ядру\
Выявление исправности синхронизации зависит от уровня оптимизации\
volatile - оптимизации вокруг этой переменной не будут применены компилятором

### 2 типа задач на синхронихацию
* производитель-потребитель
* обедающие философ
  
Мы работаем над первой, т.е. над какой-то структурой?\
Критическая секция - код, в котором данные консистентны 

### CAS - compare and swap
Атомарная операция сраванивает значение переменной с чем-то и заменяет его
```c
cas($flag, 0, 1) {
    if(*flag != 0) {
        return err;
    }
    *flag = 1;
}
```
т.е. переменная будет изменена только если такое значение она имеет

```bash
time ./prog
```

загрузка цп
```bash
htop
```

Сложение со спинлоком на разных ядрах дольше, чем на одном
т.к. конкуренции за лок не будет. На одном ядре каждый поток работает квант времени, соответсвенно потоки успеют больше раз сложить.\
На разных же ядрах каждый раз они постоянно лочатся

По хорошему, если лочка не получилась, то надо отдать поток(sched_yield()) и поток, в котором был захвачен спинлок, снова начнет работу\
Неправильно передавать управление другому потоку через sched_yield(), она по сути вызывает функцию планировщика schedule(), а планировщик может вновь отдать этот поток на выполнение\
Это работает и для разных ядр и для одного. С разными получится аналогия одного ядра по времени работы

Что значит вытеснили поток и как его вернуть?\
SpinLock по сути бесконечный цикл
```C
typedef struct {
    int lock;
} spinlock_t;

void spinlock_init(spinlock_t *s) {
    s->lock = 1;
}

void spinlock_lock(spinlock_t *s) {
    while(1) {
        int one = 1;
        if (atomic_compare_exchange_strong(&s->lock, &one, 0))
            break;
        // sched_yield();
    }
}

void spinlock_unlock(spinlock_t *s) {
    const int zero = 0;
    atomic_compare_exchange_strong(&s->lock, &zero, 1);
}
```

## Результаты
### Без синхронизации
* попыток добавить в разы больше, чем получилось примерно в 4 раза
* попыток взять в разы больше, чем получилось
* загрузка на максимум
* возможность работать только из под одного ядра
* разница add и get постоянно растет
### SpinLock
* каждая попытка добавить удалась
* примерно одинаковое раз добавили и убавили очередь
* не каждая попытка взять удалась
* загрузка на максимум
### SpinLock with usleep
* каждая попытка добавить удалась
* одинаковое количество add и get операция
* попыток get очень много
* загрузка цп writer ~7%
* загрузка цп reader 100%