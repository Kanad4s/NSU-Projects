## Синхронизация

а когда она нужна? т.к. это накладные расходы\
pthread_setaffinity_np - привязывает поток к ядру\
зависит от уровня оптимизации\
volatile - оптимизации вокруг этой переменной не будут применены компилятором

### 2 типа задач на синхронихацию
* производитель-потребитель
* обедающие философ
  
мы работаем над первой
т.е. над какой-то структурой?\
критическая секция - код, в котором данные консистентны 

### CAS - compare and swap
атомарная операция сраванивает значение переменной с чем-то и заменяет его
```c
cas($flag, 0, 1) {
    if(*flag != 0) {
        return err;
    }
    *flag = 1;
}
```
т.е. переменная будет изменена только если значение такое она имеет

```bash
time ./prog
```

загрузка цп
```bash
htop
```

Сложение со спинлоком на разных ядрах дольше, чем на одном
т.к. конкуренции за лок не будет. На одном ядре каждый поток работает квант времени, соответсвенно потоки успеют больше раз сложить.\
На разных же ядрах каждый раз они постоянно лочатся

по хорошему, если лочка не получилась, то надо отдать процесс(sched_yield()) и поток, в котором был захвачен спинлок, снова начнет работу\
это работает и для разных ядр и для одного. С разными получится аналогия одного ядра по времени работы
  
  что значит вытеснили поток и как его вернуть

## Результаты
### Без синхронизации
* попыток добавить в разы больше, чем получилось примерно в 4 раза
* попыток взять в разы больше, чем получилось
* загрузка на максимум
* возможность работать только из под одного ядра
* разница add и get постоянно растет
### SpinLock
* каждая попытка добавить удалась
* примерно одинаковое раз добавили и убавили очередь
* не каждая попытка взять удалась
* загрузка на максимум
### SpinLock with usleep
* каждая попытка добавить удалась
* одинаковое количество add и get операция
* попыток get очень много
* загрузка цп writer ~7%
* загрузка цп reader 100%