# Translation and Compilation Methods
## Block 1: знакомство с языком flow
1) Написать фукнцию, преобразующую массив целых чисел в массив строк, например:
[1, 2, 3] в ["1", "2", "3"], распечатать этот массив. Использовать функции: map, i2s,
strGlue, println.
2) Написать функцию, считающую сумму целых чисел в массиве: [1, 2, 3] в 6
Использовать функции: fold.
3) Написать функцию, fib(n : int) -> [int], вычисляющую n первых чисел фиббоначчи: 0, 1,
1, 2, 3, 5, .... Сделать ее а) рекурсивной б) с хвостовой рекурсией в) с использованием
ссылок на массив, сложности O(n). Использовать: fold, concat, refArrayPush
4) Дан массив целых чисел [n_1,...,n_k] и число m. Найти все пары индексов (i, j) такие,
что n_i + n_j == m. Сигнатура функции: inds(a : [int], m : int) -> [Pair<int, int>].
Усложнение: сделать эту функцию сложности O(n log(n)), а не O(n^2). Использовать
функции: foldi, makeTree, setTree, lookupTree.
## Block 2: знакомство с парсерами и работой с AST
1) Написать PEG-парсер грамматики простых арифметических выражений,
генерирующий AST дерево. (используя библиотеку lingo)
1) Преобразовать AST дерево арифметических выражений обратно в строковую
форму
1) Реализовать калькулятор, вычисляющий значение арифметического выражения.
1) Сделать этот калькулятор символьным, принимающим значения переменных из
командной строки
1) Расширить язык функциями степени, дробями.
   1) Калькулятор для rpn, реализующий пункты 5-9, на вход подается rpn
выражение
   1) Напишите функцию, которая преобразует алгебраическое выражение в рациональную функцию (часть многочленов).
      * "((((a + 1) / (7 * c)) * ((7 + (6 * c)) / x)) / ((3 * (a + 1)) / (x * x)))"
      * "((((x - 6) / (6 * y)) / (((x * x) - (y * y)) / y)) * (((x * x) + ((2 * (x * y)) + (y * y))) / x))"
      * "((((9 * (x * x)) - 4) / ((3 * x) + 2)) - (3 * x))"
      * "(((4 * (a * a)) - 9) * ((1 / ((2 * a) - 3)) - (1 / ((2 * a) + 3))))"
1)  Реализовать функцию упрощения алгебраического выражения (трансформация
AST дерева с сохранением семантики)
1)  Реализовать функцию символьного дифференцирования алгебраического
выражения (+ упрощение).